package controllers

import (
	"context"
	"encoding/json"
	"fmt"

	"sigs.k8s.io/controller-runtime/pkg/log"

	akamaiV1alpha1 "github.com/mmz-srf/akamai-operator/api/v1alpha1"
)

// normalizeCurrentRules converts Akamai API response rules to our PropertyRules structure
func (r *AkamaiPropertyReconciler) normalizeCurrentRules(current interface{}) (*akamaiV1alpha1.PropertyRules, error) {
	// Marshal to JSON and then unmarshal to our structure
	// This normalizes the structure and removes fields we don't care about
	currentBytes, err := json.Marshal(current)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal current rules: %w", err)
	}

	var currentRules akamaiV1alpha1.PropertyRules
	if err := json.Unmarshal(currentBytes, &currentRules); err != nil {
		return nil, fmt.Errorf("failed to unmarshal current rules: %w", err)
	}

	// Clean up Akamai-generated fields that shouldn't affect comparison
	r.cleanRulesForComparison(&currentRules)

	return &currentRules, nil
}

// cleanRulesForComparison removes or normalizes fields that shouldn't affect rule comparison
func (r *AkamaiPropertyReconciler) cleanRulesForComparison(rules *akamaiV1alpha1.PropertyRules) {
	// Remove or reset fields that are auto-generated by Akamai and don't represent meaningful changes
	// Reset UUID as it's auto-generated
	rules.UUID = ""

	// Normalize empty/default values for top-level fields
	// Empty criteriaMustSatisfy should be treated same as "all" (Akamai default)
	if rules.CriteriaMustSatisfy == "" {
		rules.CriteriaMustSatisfy = "all"
	}

	// Normalize options field - empty object or null should be treated the same
	if rules.Options.Raw != nil {
		var optionsMap map[string]interface{}
		if err := json.Unmarshal(rules.Options.Raw, &optionsMap); err == nil {
			if len(optionsMap) == 0 {
				// Empty options object, set to nil for consistency
				rules.Options.Raw = nil
			}
		}
	}

	// Normalize customOverride - null should be treated same as not present
	if rules.CustomOverride.Raw != nil {
		var customOverrideVal interface{}
		if err := json.Unmarshal(rules.CustomOverride.Raw, &customOverrideVal); err == nil {
			if customOverrideVal == nil {
				rules.CustomOverride.Raw = nil
			}
		}
	}

	// Clean up behaviors
	for i := range rules.Behaviors {
		r.cleanBehaviorForComparison(&rules.Behaviors[i])
	}

	// Clean up criteria
	for i := range rules.Criteria {
		r.cleanCriteriaForComparison(&rules.Criteria[i])
	}

	// Recursively clean child rules
	for i := range rules.Children {
		var childRule akamaiV1alpha1.PropertyRules
		if err := json.Unmarshal(rules.Children[i].Raw, &childRule); err == nil {
			r.cleanRulesForComparison(&childRule)
			// Marshal it back
			if cleanBytes, err := json.Marshal(childRule); err == nil {
				rules.Children[i].Raw = cleanBytes
			}
		}
	}
}

// cleanBehaviorForComparison cleans up behavior for comparison
func (r *AkamaiPropertyReconciler) cleanBehaviorForComparison(behavior *akamaiV1alpha1.RuleBehavior) {
	// Reset auto-generated fields
	behavior.UUID = ""

	// Normalize options by removing empty values and Akamai-generated fields
	if behavior.Options.Raw != nil {
		var options map[string]interface{}
		if err := json.Unmarshal(behavior.Options.Raw, &options); err == nil {
			r.normalizeOptionsMap(options)
			if cleanBytes, err := json.Marshal(options); err == nil {
				behavior.Options.Raw = cleanBytes
			}
		}
	}
}

// cleanCriteriaForComparison cleans up criteria for comparison
func (r *AkamaiPropertyReconciler) cleanCriteriaForComparison(criteria *akamaiV1alpha1.RuleCriteria) {
	// Reset auto-generated fields
	criteria.UUID = ""

	// Normalize options
	if criteria.Options.Raw != nil {
		var options map[string]interface{}
		if err := json.Unmarshal(criteria.Options.Raw, &options); err == nil {
			r.normalizeOptionsMap(options)
			if cleanBytes, err := json.Marshal(options); err == nil {
				criteria.Options.Raw = cleanBytes
			}
		}
	}
}

// normalizeOptionsMap normalizes an options map by removing irrelevant fields
func (r *AkamaiPropertyReconciler) normalizeOptionsMap(options map[string]interface{}) {
	// Remove fields that are commonly auto-generated or irrelevant for comparison
	fieldsToRemove := []string{
		"uuid",
		"templateUuid",
		"lastModified",
		"created",
		"etag",
		"ruleFormat",
	}

	for _, field := range fieldsToRemove {
		delete(options, field)
	}

	// Remove empty string values that might be defaults
	for key, value := range options {
		if str, ok := value.(string); ok && str == "" {
			delete(options, key)
		}
		// Remove empty maps/objects
		if mapVal, ok := value.(map[string]interface{}); ok && len(mapVal) == 0 {
			delete(options, key)
		}
		// Remove empty arrays/slices
		if sliceVal, ok := value.([]interface{}); ok && len(sliceVal) == 0 {
			delete(options, key)
		}
	}
}

// compareRulesDeep performs a deep comparison of two PropertyRules structures
func (r *AkamaiPropertyReconciler) compareRulesDeep(desired, current *akamaiV1alpha1.PropertyRules) bool {
	// Create clean copies for comparison
	desiredClean := r.copyAndCleanRules(desired)
	currentClean := r.copyAndCleanRules(current)

	// Convert both to normalized JSON for comparison
	desiredBytes, err := json.Marshal(desiredClean)
	if err != nil {
		return true // If we can't marshal, assume they're different
	}

	currentBytes, err := json.Marshal(currentClean)
	if err != nil {
		return true // If we can't marshal, assume they're different
	}

	// Normalize JSON by unmarshaling and marshaling again to ensure consistent ordering
	var desiredNormalized, currentNormalized map[string]interface{}

	if err := json.Unmarshal(desiredBytes, &desiredNormalized); err != nil {
		return true
	}
	if err := json.Unmarshal(currentBytes, &currentNormalized); err != nil {
		return true
	}

	// Final normalization pass to handle null vs empty object/array equivalence
	r.normalizeMapForComparison(desiredNormalized)
	r.normalizeMapForComparison(currentNormalized)

	desiredFinal, _ := json.Marshal(desiredNormalized)
	currentFinal, _ := json.Marshal(currentNormalized)

	// Compare normalized JSON
	different := string(desiredFinal) != string(currentFinal)

	if different {
		logger := log.FromContext(context.Background())
		logger.V(1).Info("Rules differ",
			"desired", string(desiredFinal),
			"current", string(currentFinal))
	}

	return different
}

// normalizeMapForComparison recursively normalizes a map to handle null/empty equivalence
func (r *AkamaiPropertyReconciler) normalizeMapForComparison(m map[string]interface{}) {
	for key, value := range m {
		switch v := value.(type) {
		case map[string]interface{}:
			// Recursively normalize nested maps
			r.normalizeMapForComparison(v)
			// Remove empty maps (treat as null/not present)
			if len(v) == 0 {
				delete(m, key)
			}
		case []interface{}:
			// Recursively normalize array elements
			for _, item := range v {
				if itemMap, ok := item.(map[string]interface{}); ok {
					r.normalizeMapForComparison(itemMap)
				}
			}
			// Remove empty arrays (treat as null/not present)
			if len(v) == 0 {
				delete(m, key)
			}
		case string:
			// Remove empty strings
			if v == "" {
				delete(m, key)
			}
		case nil:
			// Remove null values
			delete(m, key)
		}
	}
}

// copyAndCleanRules creates a clean copy of rules for comparison
func (r *AkamaiPropertyReconciler) copyAndCleanRules(rules *akamaiV1alpha1.PropertyRules) *akamaiV1alpha1.PropertyRules {
	if rules == nil {
		return nil
	}

	// Deep copy via JSON marshal/unmarshal
	rulesBytes, err := json.Marshal(rules)
	if err != nil {
		return rules // Return original if copy fails
	}

	var rulesCopy akamaiV1alpha1.PropertyRules
	if err := json.Unmarshal(rulesBytes, &rulesCopy); err != nil {
		return rules // Return original if copy fails
	}

	// Clean the copy
	r.cleanRulesForComparison(&rulesCopy)

	return &rulesCopy
}
